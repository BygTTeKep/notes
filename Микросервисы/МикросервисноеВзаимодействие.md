## ServiceMesh

Service mesh - Это слой инфраструктуры, который позволяет управлять связью между микросервисами приложения.

### Некоторые функции

1. Обнаружение сервисов - Service mesh автоматически обнаруживает сервисы и их endpoint'ы
2. Маршрутизация и настройка трафика - Технология направляет запросы от одного сервиса к другому, оптимизируя совместную работу всех частей приложения
3. Шифрование и аутентификация/авторизация - Service mesh обеспечивает сквозное шифрование и взаимную аутентификацию между сервисами, помогая обезопасить каналы связи
4. метрики и мониторинг - Service mesh фиксирует все аспекты взаимодействия между сервисами.

## Консистентность в распределенной системе

### Сохранение в несколько источников

#### Проблема

Допустим у нас есть бд в которую мы пишем данные, и чтото отправляем в брокер
сообщения. При этом эти операции должны выполняться атомарно.
**Первая проблема:** Нужно ли отправлять данные если бд недоступна?
**Вторая проблема:** Нужно ли сохранять данные в бд если брокер недоступен?
**Третья проблема:** Как реагировать на задержки?

#### Решение проблем

1. Распределенная транзакция - Используется 2-ух или 3-ех фазный комит
   Отправляем данные в бд, но не комитим
   Отправляем сообщение в брокер и если получаем ошибку, делаем rollback из всех систем
2. [Saga](../Проектирование/patternSaga.md)
3. CQRS/event-sourcing(переделывание архитектуры)

#### CDC(Change Data Capture)

**Потребности которые удовлетворяет CDC**

1. Вывод медленных читающих процессов из операционной бд
2. Идентичная копия данных для восстановления
3. Поставка данных как часть ETL(Extract, Transform, Load)

#### Подходы

1. Периодическая выборка(Выбор изменений за определенный период)
2. Постоянные изменения(Трансляция изменений в реальном времени)

#### Способы

1. Query-based - Выборка данных для переноса
2. Triggers - Действия выполняются в тригерах бд
3. Log-based - Использование журналов транзакций(такие решения не нагружают бд)

#### Примеры

1. Debezium
2. AWS Database Migration Service
3. Oracle Golden Gate

#### Недостатки

1. Сложность настройки и управления
2. Неуправляемые задержки(нет гарантии своевременной доставки)
3. Консистентность(сложность управления транакциями в случае изменения в разных таблицах)

Также есть сложность настраивания avro схемы, если используется

#### Transactional outbox

Паттерн для обеспечения гарантированной доставки сообщений в распределенных системах при
интеграции с использованием асинхронных коммуникаций таких как очереди сообщений или лог изменений
**Основная идей**
В одной тразакции сохраняем и нашу бизнес ссущность и событе для отправки в специальную таблицу
Эта запись в специальной таблице - **outbox** совершается в той же транзакции что и основные изменения
данных, таким образом обеспечивается их атомарность.
Затем отдельный компанени или сервис выбирает эти события и отправляет.
После успешной публикации сообщение удаляется из **outbox** или помечается как обработанное.
Пример:

```
CREATE TABLE otbox_table
(
    id BIGINT NOT NULL
    created_dttm TIMESTAMP NOT NULL
    entity_name VARCHAR(50) NOT NULL
    payload TEXT NOT NULL
)
partitional by RANGE(created_dttm)
```

Правильным удаление будет использовать партиционирование для удаления так как в данном случае мы можем удалить
всю партицию, а не выполнять массовое удаление строк из большой таблицы.
(ALTER TABLE DETACH PARTITION)

PG из коробки не умеет создавать и удалять партиции автоматически
**Решения**
[Timescale-db](https://docs.timescale.com/) и cron-job

#### Выборка из бд

1. Пессимистическая блокировка

```
SELECT * FROM outbox_table
WHERE
created_dttm BETWEEN current_date - interval '1 minute'
AND
current_date
FOR UPDATE SKIP LOCKED
```

Здесь важна транзакционность, но есть проблемы

1. Долгая транзакция
2. Блокировка строк(повышает нагрузку на бд)
   Для решения можно ввести status

```
CREATE TABLE otbox_table
(
    id BIGINT NOT NULL
    created_dttm TIMESTAMP NOT NULL
    entity_name VARCHAR(50) NOT NULL
    payload TEXT NOT NULL
    status varchar(20) NOT NULL
)
partitional by RANGE(created_dttm)
create index ... on outbox_table(created_dttm) where status='new'
```

Очередность выполнения будет выглядить

1. Блокируем записи

```
UPDATE outbox_table SET status='locked'
WHERE id in (
    SELECT * FROM outbox_table
    WHERE status='new'
    FOR UPDATE SKIP LOCKED
)
RETURNING id
```

2. Отправляем их
3. Обновляем статус

Проблема которая может возникнуть - если чтото упало и статус не поменялся
тогда событие может остаться со статусом 'locked'. Для решения это проблемы
нужен отдельный компанент для отправки зависших строк

#### Проблемы очередей в бд

1. Долгие транзакции
2. Частые обновления(status) порождают vacuum

#### Решение(Отправка по сдвигу)

В отдельной таблице будем хранить информацию об отправке

```
CREATE TABLE outbox_counter
(
    counter_key varchar(50)
    counter_value bigint
    update_dttm timestamp
)
```

Используем время для выполнения отправки
**Проблемы**

1. Задержки
2. Разница во времени на бд и на инстансах приложения
3. Возможны подстроки времени для синхронизации( разные гео )
