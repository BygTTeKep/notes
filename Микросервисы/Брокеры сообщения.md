#

## Основные понятия

Продюсер(Producer) - приложение или процесс, генерирующий сообщения в Kafka.
Продюсеры могут публиковать данные в один или несколько топиков.

---

Топик(Topic) - Логическая категория или канал, в которые продюсеры отправляют сообщения.

---

Потребитель(Consumer) - приложение или процесс, который получает и обрабатывает сообщения от продюсеров

---

Партиция(Partition) - Деление топика на более мелкие части для повышения производительности.
Каждая партиция представляет собой упорядоченный лог сообщений.

---

Брокер(Broker) - Сервер который хранит данные и отправляет сообщения между продюсерами и потребителями
Брокеры объединяеются в кластеры для обеспечения отказоустойчивости и масштабируемости.

Консюмеры получают данные с сервера, используя две разные модели запросов pull и push

### Pull модель

Консюмеры сами отправляют запрос раз в n секунд на сервер для получения новой порции сообщений.
При таком подходе клиенты сами могут контролировать собственную нагрузку. Pull модель позволяет
группировать сообщения в батчи, таким образом достигая лучшей пропускной способности.
Из минусов можно отметить что у такой модели может быть потенциальная разбалансировка нагрузки между
разными консюмерами, а также можно отнести более высокую задержку обработки данных.

### Push модель

В такой модели сервер делает запрос к клиенту посылая ему новую порцию данных.
Она снижает задержку обработки сообщений и позволяет
эффективно балансировать распределение сообщений между консюмерами.
Но для предотвращения перегрузки консюмеров в случае с RabbitMQ
клиентам приходится использовать функционал QS, выставляя лимиты.

## Жизненый цикл сообщений в системах очередей

1. Продюсер отправляет сообщение на сервер
2. Консюмер фетчит сообщение и его уникальный индентификатор сервера(id)
3. Сервер помечает сообщение как in-flight
   Сообщения в таком состоянии хранятся на сервере, но временно не доставляются консюмерам
   Таймаут этого состояния контролируется специальной настройкой
4. Консмюмер обрабатывает сообщение, следуя бизнес логики.
   Затем отправляет ack или nack запрос обратно на сервер, используя уникальный id,
   тем самым либо подтверждая успешную обработку сообщения либо сигнализируя об ошибке.
5. В случае успеха сообщение удаляется с сервера навсегда.
   В случае ошибки или таймаута состояния in-flight сообщение достаялвяется консюмеру для повторной обрабокти

# [Kafka](Kafka.md)
