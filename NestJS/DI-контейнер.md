# Как работает DI контейнер в NestJS

В NestJS контейнер DI управляет созданием и внедрением зависимостей, автоматически создвая экзепляры классов и передавая их в нужные места.
Он делает это с помощью рефлексии(metadata) и механизма провайдеров

## Основные этапы

1. NestJS анализирует модули и регистрирует все провайдерыв providers, controllers, exports
2. Разрешение зависимостей. Когда в другом модуле требуется какой либо сервис, NestJS автоматически передаст его в конструктор через DI

## Жизненый цикл DI-контейнера

1. Сканирование модулей и регистрация всех классов
2. Создание экземпляров классов(если они используются гдето)
3. Внедрение зависимостей(Если они запрашиваются через конструктор)

## Как DI контейнер находит и внедряет зависимости

NestJS использует рефлексию(metadata) и Token-based Injection

-   Рефлексия(reflect metadata)
    NestJS анализирует метаданные о классах(через reflect-metadata), чтобы понять какие зависимости нужны
-   Token-based Injection
    Когда мы регистрируем провайдер, он получает уникальный токен(обычно это имя класса). Когда другой класс запрашивает зависимость, NestJS ищет в контейнере провайдер с таким токеном и передает его

## @Injectable @Inject

@Injectable - делает класс доступным для DI
@Inject - используется для ручно внедрения зависимостей по токену
